package massiveandslice

func Sum(numbers []int) int {
	var sum int = 0
	/*
		range позволяет выполнять итерацию по массиву.
		На каждой итерации range возвращает два значения — индекс и значение.
		Мы решили игнорировать значение индекса, используя _ пустой идентификатор
	*/
	for _, number := range numbers {
		sum += number
	}
	return sum
}

/*
Для написания функции, которая принимает разное количество аргументов одного типа
достаточно использовать ... перед указанием типа.
Для всех входящих значений будет инициализироваться срез с переданными в функцию значениями
*/
func SumAll(numbersToSum ...[]int) []int {
	var sums []int
	/* полная команда + объяснение
	make([]int, 0, 5) - создаст слайс, в котором изначально нет элементов
	но допускается, что их будет до 5 штук. Предельное кол-во = ёмкость (cap)
	Когда элементов будет больше 5, то Go
	самостоятельно увеличит предельное количество элементов примерно в 2 раза
	Маханизм позволяет избежать излишних аллокаций.
	Для добавления элемента используется append:
	append(name_of_slice, ... arguments)

	Пример:
	s := make([]int, 0, 4)
	s = append(s, 1, 2, 3)
	fmt.Println(len(s), cap(s)) // 3 4.  Т.е - сейчас в слайсе 3 элемента, но можно 4

		Итого:
	len — сколько элементов есть
	cap — сколько элементов можно добавить без realloc
	append перераспределяет память, если len > cap
	*/
	for _, numbers := range numbersToSum {
		sums = append(sums, Sum(numbers))
	}
	return sums
}
